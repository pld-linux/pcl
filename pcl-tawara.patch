diff -urN pcl-pcl-1.7.2.org/tools/CMakeLists.txt pcl-pcl-1.7.2/tools/CMakeLists.txt
--- pcl-pcl-1.7.2.org/tools/CMakeLists.txt	2014-09-10 23:22:57.000000000 +0200
+++ pcl-pcl-1.7.2/tools/CMakeLists.txt	2014-11-07 15:21:20.377848947 +0100
@@ -253,14 +253,14 @@
   PCL_ADD_EXECUTABLE (pcl_transform_from_viewpoint "${SUBSYS_NAME}" transform_from_viewpoint.cpp)
   target_link_libraries (pcl_transform_from_viewpoint pcl_common pcl_io pcl_registration)
 
-  find_package(tide QUIET)
-  if(Tide_FOUND)
-      include_directories(${Tide_INCLUDE_DIRS})
-      add_definitions(${Tide_DEFINITIONS})
+  find_package(tawara QUIET)
+  if(Tawara_FOUND)
+      include_directories(${Tawara_INCLUDE_DIRS})
+      add_definitions(${Tawara_DEFINITIONS})
       PCL_ADD_EXECUTABLE(pcl_video "${SUBSYS_NAME}" pcl_video.cpp)
       target_link_libraries(pcl_video pcl_common pcl_io pcl_visualization
-          ${Tide_LIBRARIES})
-  endif(Tide_FOUND)
+          ${Tawara_LIBRARIES})
+  endif(Tawara_FOUND)
   
 
 endif (BUILD_tools)
diff -urN pcl-pcl-1.7.2.org/tools/pcl_video.cpp pcl-pcl-1.7.2/tools/pcl_video.cpp
--- pcl-pcl-1.7.2.org/tools/pcl_video.cpp	2014-09-10 23:22:57.000000000 +0200
+++ pcl-pcl-1.7.2/tools/pcl_video.cpp	2014-11-07 15:21:20.377848947 +0100
@@ -36,13 +36,13 @@
 
 #include <iostream>
 #include <string>
-#include <tide/ebml_element.h>
-#include <tide/file_cluster.h>
-#include <tide/segment.h>
-#include <tide/simple_block.h>
-#include <tide/tide_impl.h>
-#include <tide/tracks.h>
-#include <tide/track_entry.h>
+#include <tawara/ebml_element.h>
+#include <tawara/file_cluster.h>
+#include <tawara/segment.h>
+#include <tawara/simple_block.h>
+#include <tawara/tawara_impl.h>
+#include <tawara/tracks.h>
+#include <tawara/track_entry.h>
 #include <pcl/point_cloud.h>
 #include <pcl/point_types.h>
 #include <pcl/io/openni_grabber.h>
@@ -74,12 +74,12 @@
             // cluster's timecode measured in the segment's timecode scale.
             bpt::ptime blk_start(bpt::microsec_clock::local_time());
             bpt::time_duration blk_offset = blk_start - cltr_start_;
-            tide::BlockElement::Ptr block(new tide::SimpleBlock(1,
+            tawara::BlockElement::Ptr block(new tawara::SimpleBlock(1,
                         blk_offset.total_microseconds() / 10000));
             // Here the frame data itself is added to the block
             pcl::PCLPointCloud2 blob;
             pcl::toPCLPointCloud2(*cloud, blob);
-            tide::Block::FramePtr frame_ptr(new tide::Block::Frame(blob.data.begin(),
+            tawara::Block::FramePtr frame_ptr(new tawara::Block::Frame(blob.data.begin(),
                         blob.data.end()));
             block->push_back(frame_ptr);
             cluster_->push_back(block);
@@ -106,7 +106,7 @@
                 // Create a new cluster
                 cltr_start_ = bpt::microsec_clock::local_time();
                 bpt::time_duration cltr_offset = cltr_start_ - seg_start_;
-                cluster_.reset(new tide::FileCluster(
+                cluster_.reset(new tawara::FileCluster(
                             cltr_offset.total_microseconds() / 10000));
                 cluster_->write(stream_);
             }
@@ -115,14 +115,14 @@
         int Run()
         {
             // Write the EBML PCLHeader. This specifies that the file is an EBML
-            // file, and is a Tide document.
-            tide::EBMLElement ebml_el;
+            // file, and is a Tawara document.
+            tawara::EBMLElement ebml_el;
             ebml_el.write(stream_);
 
             // Open a new segment in the file. This will write some initial meta-data
             // and place some padding at the start of the file for final meta-data to
             // be written after tracks, clusters, etc. have been written.
-            tide::Segment segment;
+            tawara::Segment segment;
             segment.write(stream_);
             // Set up the segment information so it can be used while writing tracks
             // and clusters.
@@ -136,7 +136,7 @@
             segment.info.filename(filename_);
             // The segment's timecode scale is possibly the most important value in the
             // segment meta-data data. Without it, timely playback of frames is not
-            // possible. It has a sensible default (defined in the Tide specification),
+            // possible. It has a sensible default (defined in the Tawara specification),
             // but here we set it to ten milliseconds for demonstrative purposes.
             segment.info.timecode_scale(10000000);
             // The segment's date should be set. It is the somewhat-awkward value of
@@ -148,16 +148,16 @@
             segment.info.date(td.total_microseconds() * 1000);
             // Let's give the segment an inspirational title.
             segment.info.title(title_);
-            // It sometimes helps to know what created a Tide file.
-            segment.info.muxing_app("libtide-0.1");
+            // It sometimes helps to know what created a Tawara file.
+            segment.info.muxing_app("libtawara-0.1");
             segment.info.writing_app("pcl_video");
 
             // Set up the tracks meta-data and write it to the file.
-            tide::Tracks tracks;
+            tawara::Tracks tracks;
             // Each track is represented in the Tracks information by a TrackEntry.
             // This specifies such things as the track number, the track's UID and the
             // codec used.
-            tide::TrackEntry::Ptr track(new tide::TrackEntry(1, 1, "pointcloud2"));
+            tawara::TrackEntry::Ptr track(new tawara::TrackEntry(1, 1, "pointcloud2"));
             track->name("3D video");
             track->codec_name("pcl::PCLPointCloud2");
             // Adding each level 1 element (only the first occurance, in the case of
@@ -183,7 +183,7 @@
             // seconds being usable.
             // The first cluster will appear at this point in the file, so it is
             // recorded in the segment's index for faster file reading.
-            segment.index.insert(std::make_pair(tide::ids::Cluster,
+            segment.index.insert(std::make_pair(tawara::ids::Cluster,
                         segment.to_segment_offset(stream_.tellp())));
 
             // Set up a callback to get clouds from a grabber and write them to the
@@ -195,7 +195,7 @@
             // Start the first cluster
             cltr_start_ = bpt::microsec_clock::local_time();
             bpt::time_duration cltr_offset = cltr_start_ - seg_start_;
-            cluster_.reset(new tide::FileCluster(
+            cluster_.reset(new tawara::FileCluster(
                         cltr_offset.total_microseconds() / 10000));
             cluster_->write(stream_);
             last_ = pcl::getTime();
@@ -224,7 +224,7 @@
         std::string filename_;
         std::string title_;
         std::fstream stream_;
-        tide::FileCluster::Ptr cluster_;
+        tawara::FileCluster::Ptr cluster_;
         bpt::ptime seg_start_;
         bpt::ptime cltr_start_;
         unsigned int count_;
@@ -245,30 +245,30 @@
         int Run()
         {
             // Open the file and check for the EBML header. This confirms that the file
-            // is an EBML file, and is a Tide document.
+            // is an EBML file, and is a Tawara document.
             std::ifstream stream(filename_, std::ios::in);
-            tide::ids::ReadResult id = tide::ids::read(stream);
-            if (id.first != tide::ids::EBML)
+            tawara::ids::ReadResult id = tawara::ids::read(stream);
+            if (id.first != tawara::ids::EBML)
             {
                 std::cerr << "File does not begin with an EBML header.\n";
                 return 1;
             }
-            tide::EBMLElement ebml_el;
+            tawara::EBMLElement ebml_el;
             ebml_el.read(stream);
-            if (ebml_el.doc_type() != tide::TideDocType)
+            if (ebml_el.doc_type() != tawara::TawaraDocType)
             {
-                std::cerr << "Specified EBML file is not a Tide document.\n";
+                std::cerr << "Specified EBML file is not a Tawara document.\n";
                 return 1;
             }
-            if (ebml_el.read_version() > tide::TideEBMLVersion)
+            if (ebml_el.read_version() > tawara::TawaraEBMLVersion)
             {
-                std::cerr << "This Tide document requires read version " <<
+                std::cerr << "This Tawara document requires read version " <<
                     ebml_el.read_version() << ".\n";
                 return 1;
             }
-            if (ebml_el.doc_read_version() > tide::TideVersionMajor)
+            if (ebml_el.doc_read_version() > tawara::TawaraVersionMajor)
             {
-                std::cerr << "This Tide document requires doc read version " <<
+                std::cerr << "This Tawara document requires doc read version " <<
                     ebml_el.read_version() << ".\n";
                 return 1;
             }
@@ -278,13 +278,13 @@
             // and read (or build, if necessary) an index of the level 1 elements. With
             // this index, we will be able to quickly jump to important elements such
             // as the Tracks and the first Cluster.
-            id = tide::ids::read(stream);
-            if (id.first != tide::ids::Segment)
+            id = tawara::ids::read(stream);
+            if (id.first != tawara::ids::Segment)
             {
                 std::cerr << "Segment element not found\n";
                 return 1;
             }
-            tide::Segment segment;
+            tawara::Segment segment;
             segment.read(stream);
             // The segment's date is stored as the number of nanoseconds since the
             // start of the millenium. Boost::Date_Time is invaluable here.
@@ -298,18 +298,18 @@
             // one will exist).
             // We can guarantee that there is at least one in the index because
             // otherwise the call to segment.read() would have thrown an error.
-            std::streampos tracks_pos(segment.index.find(tide::ids::Tracks)->second);
+            std::streampos tracks_pos(segment.index.find(tawara::ids::Tracks)->second);
             stream.seekg(segment.to_stream_offset(tracks_pos));
             // To be sure, we can check it really is a Tracks element, but this is
             // usually not necessary.
-            id = tide::ids::read(stream);
-            if (id.first != tide::ids::Tracks)
+            id = tawara::ids::read(stream);
+            if (id.first != tawara::ids::Tracks)
             {
                 std::cerr << "Tracks element not at indicated position.\n";
                 return 1;
             }
             // Read the tracks
-            tide::Tracks tracks;
+            tawara::Tracks tracks;
             tracks.read(stream);
             // Now we can introspect the tracks available in the file.
             if (tracks.empty())
@@ -334,7 +334,7 @@
             // reads blocks from the file on demand. This is usually a better
             // option tham the memory-based cluster when the size of the stored
             // data is large.
-            for (tide::Segment::FileBlockIterator block(segment.blocks_begin_file(stream));
+            for (tawara::Segment::FileBlockIterator block(segment.blocks_begin_file(stream));
                     block != segment.blocks_end_file(stream); ++block)
             {
                 bpt::time_duration blk_offset(bpt::microseconds((
@@ -354,7 +354,7 @@
                 // so there is only one frame per block. This is the general
                 // case; lacing is typically only used when the frame size is
                 // very small to reduce overhead.
-                tide::BlockElement::FramePtr frame_data(*block->begin());
+                tawara::BlockElement::FramePtr frame_data(*block->begin());
                 // Copy the frame data into a serialised cloud structure
                 pcl::PCLPointCloud2 blob;
                 blob.height = 480;
--- pcl-pcl-1.7.0/tools/pcl_video.cpp.orig	2013-09-20 15:25:35.239248341 +0200
+++ pcl-pcl-1.7.0/tools/pcl_video.cpp	2013-09-20 19:03:40.298699215 +0200
@@ -36,6 +36,8 @@
 
 #include <iostream>
 #include <string>
+#include <boost/uuid/random_generator.hpp>
+#include <boost/uuid/uuid.hpp>
 #include <tawara/ebml_element.h>
 #include <tawara/file_cluster.h>
 #include <tawara/segment.h>
@@ -61,7 +63,7 @@
     public:
         Recorder(std::string const& filename, std::string const& title)
             : filename_(filename), title_(title),
-            stream_(filename, std::ios::in|std::ios::out|std::ios::trunc),
+            stream_(filename.c_str(), std::ios::in|std::ios::out|std::ios::trunc),
             count_(0)
         {
         }
@@ -248,7 +248,7 @@ class Player
         {
             // Open the file and check for the EBML header. This confirms that the file
             // is an EBML file, and is a Tawara document.
-            std::ifstream stream(filename_, std::ios::in);
+            std::ifstream stream(filename_.c_str(), std::ios::in);
             tawara::ids::ReadResult id = tawara::ids::read(stream);
             if (id.first != tawara::ids::EBML)
             {

